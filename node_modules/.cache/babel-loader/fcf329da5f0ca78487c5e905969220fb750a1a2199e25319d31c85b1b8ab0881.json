{"ast":null,"code":"import { getRandom, getRangeValue } from \"@tsparticles/engine\";\nimport { Wobble } from \"./Options/Classes/Wobble.js\";\nimport { updateWobble } from \"./Utils.js\";\nconst double = 2,\n  doublePI = Math.PI * double,\n  maxAngle = 360,\n  moveSpeedFactor = 10,\n  defaultDistance = 0;\nexport class WobbleUpdater {\n  constructor(container) {\n    this.container = container;\n  }\n  init(particle) {\n    var _wobbleOpt$distance;\n    const wobbleOpt = particle.options.wobble;\n    if (wobbleOpt !== null && wobbleOpt !== void 0 && wobbleOpt.enable) {\n      particle.wobble = {\n        angle: getRandom() * doublePI,\n        angleSpeed: getRangeValue(wobbleOpt.speed.angle) / maxAngle,\n        moveSpeed: getRangeValue(wobbleOpt.speed.move) / moveSpeedFactor\n      };\n    } else {\n      particle.wobble = {\n        angle: 0,\n        angleSpeed: 0,\n        moveSpeed: 0\n      };\n    }\n    particle.retina.wobbleDistance = getRangeValue((_wobbleOpt$distance = wobbleOpt === null || wobbleOpt === void 0 ? void 0 : wobbleOpt.distance) !== null && _wobbleOpt$distance !== void 0 ? _wobbleOpt$distance : defaultDistance) * this.container.retina.pixelRatio;\n  }\n  isEnabled(particle) {\n    var _particle$options$wob;\n    return !particle.destroyed && !particle.spawning && !!((_particle$options$wob = particle.options.wobble) !== null && _particle$options$wob !== void 0 && _particle$options$wob.enable);\n  }\n  loadOptions(options) {\n    if (!options.wobble) {\n      options.wobble = new Wobble();\n    }\n    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      sources[_key - 1] = arguments[_key];\n    }\n    for (const source of sources) {\n      options.wobble.load(source === null || source === void 0 ? void 0 : source.wobble);\n    }\n  }\n  update(particle, delta) {\n    if (!this.isEnabled(particle)) {\n      return;\n    }\n    updateWobble(particle, delta);\n  }\n}","map":{"version":3,"names":["getRandom","getRangeValue","Wobble","updateWobble","double","doublePI","Math","PI","maxAngle","moveSpeedFactor","defaultDistance","WobbleUpdater","constructor","container","init","particle","_wobbleOpt$distance","wobbleOpt","options","wobble","enable","angle","angleSpeed","speed","moveSpeed","move","retina","wobbleDistance","distance","pixelRatio","isEnabled","_particle$options$wob","destroyed","spawning","loadOptions","_len","arguments","length","sources","Array","_key","source","load","update","delta"],"sources":["D:/ReactApp/node_modules/@tsparticles/updater-wobble/browser/WobbleUpdater.js"],"sourcesContent":["import { getRandom, getRangeValue, } from \"@tsparticles/engine\";\nimport { Wobble } from \"./Options/Classes/Wobble.js\";\nimport { updateWobble } from \"./Utils.js\";\nconst double = 2, doublePI = Math.PI * double, maxAngle = 360, moveSpeedFactor = 10, defaultDistance = 0;\nexport class WobbleUpdater {\n    constructor(container) {\n        this.container = container;\n    }\n    init(particle) {\n        const wobbleOpt = particle.options.wobble;\n        if (wobbleOpt?.enable) {\n            particle.wobble = {\n                angle: getRandom() * doublePI,\n                angleSpeed: getRangeValue(wobbleOpt.speed.angle) / maxAngle,\n                moveSpeed: getRangeValue(wobbleOpt.speed.move) / moveSpeedFactor,\n            };\n        }\n        else {\n            particle.wobble = {\n                angle: 0,\n                angleSpeed: 0,\n                moveSpeed: 0,\n            };\n        }\n        particle.retina.wobbleDistance =\n            getRangeValue(wobbleOpt?.distance ?? defaultDistance) * this.container.retina.pixelRatio;\n    }\n    isEnabled(particle) {\n        return !particle.destroyed && !particle.spawning && !!particle.options.wobble?.enable;\n    }\n    loadOptions(options, ...sources) {\n        if (!options.wobble) {\n            options.wobble = new Wobble();\n        }\n        for (const source of sources) {\n            options.wobble.load(source?.wobble);\n        }\n    }\n    update(particle, delta) {\n        if (!this.isEnabled(particle)) {\n            return;\n        }\n        updateWobble(particle, delta);\n    }\n}\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,aAAa,QAAS,qBAAqB;AAC/D,SAASC,MAAM,QAAQ,6BAA6B;AACpD,SAASC,YAAY,QAAQ,YAAY;AACzC,MAAMC,MAAM,GAAG,CAAC;EAAEC,QAAQ,GAAGC,IAAI,CAACC,EAAE,GAAGH,MAAM;EAAEI,QAAQ,GAAG,GAAG;EAAEC,eAAe,GAAG,EAAE;EAAEC,eAAe,GAAG,CAAC;AACxG,OAAO,MAAMC,aAAa,CAAC;EACvBC,WAAWA,CAACC,SAAS,EAAE;IACnB,IAAI,CAACA,SAAS,GAAGA,SAAS;EAC9B;EACAC,IAAIA,CAACC,QAAQ,EAAE;IAAA,IAAAC,mBAAA;IACX,MAAMC,SAAS,GAAGF,QAAQ,CAACG,OAAO,CAACC,MAAM;IACzC,IAAIF,SAAS,aAATA,SAAS,eAATA,SAAS,CAAEG,MAAM,EAAE;MACnBL,QAAQ,CAACI,MAAM,GAAG;QACdE,KAAK,EAAErB,SAAS,CAAC,CAAC,GAAGK,QAAQ;QAC7BiB,UAAU,EAAErB,aAAa,CAACgB,SAAS,CAACM,KAAK,CAACF,KAAK,CAAC,GAAGb,QAAQ;QAC3DgB,SAAS,EAAEvB,aAAa,CAACgB,SAAS,CAACM,KAAK,CAACE,IAAI,CAAC,GAAGhB;MACrD,CAAC;IACL,CAAC,MACI;MACDM,QAAQ,CAACI,MAAM,GAAG;QACdE,KAAK,EAAE,CAAC;QACRC,UAAU,EAAE,CAAC;QACbE,SAAS,EAAE;MACf,CAAC;IACL;IACAT,QAAQ,CAACW,MAAM,CAACC,cAAc,GAC1B1B,aAAa,EAAAe,mBAAA,GAACC,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEW,QAAQ,cAAAZ,mBAAA,cAAAA,mBAAA,GAAIN,eAAe,CAAC,GAAG,IAAI,CAACG,SAAS,CAACa,MAAM,CAACG,UAAU;EAChG;EACAC,SAASA,CAACf,QAAQ,EAAE;IAAA,IAAAgB,qBAAA;IAChB,OAAO,CAAChB,QAAQ,CAACiB,SAAS,IAAI,CAACjB,QAAQ,CAACkB,QAAQ,IAAI,CAAC,GAAAF,qBAAA,GAAChB,QAAQ,CAACG,OAAO,CAACC,MAAM,cAAAY,qBAAA,eAAvBA,qBAAA,CAAyBX,MAAM;EACzF;EACAc,WAAWA,CAAChB,OAAO,EAAc;IAC7B,IAAI,CAACA,OAAO,CAACC,MAAM,EAAE;MACjBD,OAAO,CAACC,MAAM,GAAG,IAAIjB,MAAM,CAAC,CAAC;IACjC;IAAC,SAAAiC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAHmBC,OAAO,OAAAC,KAAA,CAAAJ,IAAA,OAAAA,IAAA,WAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;MAAPF,OAAO,CAAAE,IAAA,QAAAJ,SAAA,CAAAI,IAAA;IAAA;IAI3B,KAAK,MAAMC,MAAM,IAAIH,OAAO,EAAE;MAC1BpB,OAAO,CAACC,MAAM,CAACuB,IAAI,CAACD,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEtB,MAAM,CAAC;IACvC;EACJ;EACAwB,MAAMA,CAAC5B,QAAQ,EAAE6B,KAAK,EAAE;IACpB,IAAI,CAAC,IAAI,CAACd,SAAS,CAACf,QAAQ,CAAC,EAAE;MAC3B;IACJ;IACAZ,YAAY,CAACY,QAAQ,EAAE6B,KAAK,CAAC;EACjC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}